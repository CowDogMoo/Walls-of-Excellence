---
# yaml-language-server: $schema=https://kubernetes-schemas.pages.dev/helm.toolkit.fluxcd.io/helmrelease_v2.json
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: vector-syslog
  namespace: observability
spec:
  interval: 1h
  chart:
    spec:
      chart: vector
      version: 0.45.0
      sourceRef:
        kind: HelmRepository
        name: vector
        namespace: flux-system
  install:
    remediation:
      retries: -1
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  values:
    role: Stateless-Aggregator
    service:
      type: LoadBalancer
      ports:
        - name: syslog-udp
          port: 514
          protocol: UDP
          targetPort: 514
    env:
      - name: VECTOR_LOG
        value: "info"
    customConfig:
      data_dir: /vector-data-dir
      api:
        enabled: true
        address: "0.0.0.0:8686"
      sources:
        unifi_raw:
          type: socket
          address: "0.0.0.0:514"
          mode: udp
          decoding:
            codec: bytes
      transforms:
        parse_unifi_cef:
          type: remap
          inputs: ["unifi_raw"]
          source: |
            # Ensure message is a string using to_string with a fallback
            .message = to_string(.message) ?? ""

            # Initialize default values for required labels
            .event_type = "raw_syslog"
            .unifi_category = "unknown"
            .unifi_subcategory = "unknown"
            .unifi_host = "unknown"
            .severity = "unknown"

            # Store the original message for processing
            working_message = .message

            # Check if this is a syslog-wrapped message
            if starts_with(working_message, "<") {
              # Parse syslog wrapper first
              parsed_syslog, err = parse_syslog(working_message)
              if err == null {
                working_message = to_string(parsed_syslog.message)
                .syslog_timestamp = parsed_syslog.timestamp
                .syslog_hostname = parsed_syslog.hostname
                .syslog_facility = parsed_syslog.facility
                .syslog_severity = parsed_syslog.severity
              }
            }

            # Check if the message contains CEF data
            if contains(working_message, "CEF:") {
              # Extract the CEF portion from the message
              # Handle cases like "Sep 09 00:02:00 UDMPRO CEF:0|..."
              parts = split(working_message, "CEF:", limit: 2)

              if length(parts) > 1 {
                cef_content = to_string(parts[1])

                # Manual CEF parsing - split the header fields (first 6 pipes)
                cef_parts = split(cef_content, "|", limit: 7)

                if length(cef_parts) >= 6 {
                  # Parse CEF header fields
                  .cef_version = to_string(cef_parts[0])
                  .device_vendor = to_string(cef_parts[1])
                  .device_product = to_string(cef_parts[2])
                  .device_version = to_string(cef_parts[3])
                  .device_event_class_id = to_string(cef_parts[4])
                  .name = to_string(cef_parts[5])

                  # Parse extensions (everything after the 6th pipe)
                  if length(cef_parts) > 6 {
                    extension = to_string(cef_parts[6])

                    # Check if extension starts with a number (severity)
                    first_char = slice(extension, 0, 1) ?? ""
                    if contains("0123456789", first_char) {
                      # Extract severity from the beginning
                      sev_parts = split(extension, "|", limit: 2)
                      .severity = to_string(sev_parts[0])
                      if length(sev_parts) > 1 {
                        extension = to_string(sev_parts[1])
                      } else {
                        extension = ""
                      }
                    } else {
                      .severity = "0"
                    }

                    # Parse extension fields - handle msg field specially since it can contain spaces
                    if contains(extension, "msg=") {
                      msg_parts = split(extension, "msg=", limit: 2)
                      if length(msg_parts) > 1 {
                        msg_str = to_string(msg_parts[1])
                        # msg field goes to the end or until we hit another known field
                        # Check for other fields that might follow
                        if contains(msg_str, " UNIFI") {
                          msg_end = split(msg_str, " UNIFI", limit: 2)
                          .msg = to_string(msg_end[0])
                          # Reconstruct the rest for further parsing
                          if length(msg_end) > 1 {
                            extension = "UNIFI" + to_string(msg_end[1])
                          }
                        } else if contains(msg_str, " src=") {
                          msg_end = split(msg_str, " src=", limit: 2)
                          .msg = to_string(msg_end[0])
                          if length(msg_end) > 1 {
                            extension = "src=" + to_string(msg_end[1])
                          }
                        } else if contains(msg_str, " dst=") {
                          msg_end = split(msg_str, " dst=", limit: 2)
                          .msg = to_string(msg_end[0])
                          if length(msg_end) > 1 {
                            extension = "dst=" + to_string(msg_end[1])
                          }
                        } else {
                          # msg is the last field
                          .msg = msg_str
                          extension = ""
                        }
                      }
                    }

                    # Parse other standard CEF fields
                    if contains(extension, "src=") {
                      src_parts = split(extension, "src=", limit: 2)
                      if length(src_parts) > 1 {
                        src_str = to_string(src_parts[1])
                        src_value = split(src_str, " ", limit: 2)
                        .source_ip = to_string(src_value[0])
                      }
                    }

                    if contains(extension, "dst=") {
                      dst_parts = split(extension, "dst=", limit: 2)
                      if length(dst_parts) > 1 {
                        dst_str = to_string(dst_parts[1])
                        dst_value = split(dst_str, " ", limit: 2)
                        .destination_ip = to_string(dst_value[0])
                      }
                    }

                    if contains(extension, "spt=") {
                      spt_parts = split(extension, "spt=", limit: 2)
                      if length(spt_parts) > 1 {
                        spt_str = to_string(spt_parts[1])
                        spt_value = split(spt_str, " ", limit: 2)
                        .source_port = to_string(spt_value[0])
                      }
                    }

                    if contains(extension, "dpt=") {
                      dpt_parts = split(extension, "dpt=", limit: 2)
                      if length(dpt_parts) > 1 {
                        dpt_str = to_string(dpt_parts[1])
                        dpt_value = split(dpt_str, " ", limit: 2)
                        .destination_port = to_string(dpt_value[0])
                      }
                    }

                    # Parse UniFi specific fields
                    if contains(extension, "UNIFIhost=") {
                      host_parts = split(extension, "UNIFIhost=", limit: 2)
                      if length(host_parts) > 1 {
                        host_str = to_string(host_parts[1])
                        host_value = split(host_str, " ", limit: 2)
                        .unifi_host = to_string(host_value[0])
                      }
                    }

                    if contains(extension, "UNIFIcategory=") {
                      cat_parts = split(extension, "UNIFIcategory=", limit: 2)
                      if length(cat_parts) > 1 {
                        cat_str = to_string(cat_parts[1])
                        cat_value = split(cat_str, " ", limit: 2)
                        .unifi_category = to_string(cat_value[0])
                      }
                    }

                    if contains(extension, "UNIFIsubCategory=") {
                      subcat_parts = split(extension, "UNIFIsubCategory=", limit: 2)
                      if length(subcat_parts) > 1 {
                        subcat_str = to_string(subcat_parts[1])
                        subcat_value = split(subcat_str, " ", limit: 2)
                        .unifi_subcategory = to_string(subcat_value[0])
                      }
                    }

                    if contains(extension, "UNIFIadmin=") {
                      admin_parts = split(extension, "UNIFIadmin=", limit: 2)
                      if length(admin_parts) > 1 {
                        admin_str = to_string(admin_parts[1])
                        admin_value = split(admin_str, " ", limit: 2)
                        .unifi_admin = to_string(admin_value[0])
                      }
                    }

                    if contains(extension, "UNIFIaccessMethod=") {
                      method_parts = split(extension, "UNIFIaccessMethod=", limit: 2)
                      if length(method_parts) > 1 {
                        method_str = to_string(method_parts[1])
                        method_value = split(method_str, " ", limit: 2)
                        .unifi_access_method = to_string(method_value[0])
                      }
                    }

                    # Client fields
                    if contains(extension, "UNIFIclientIp=") {
                      cip_parts = split(extension, "UNIFIclientIp=", limit: 2)
                      if length(cip_parts) > 1 {
                        cip_str = to_string(cip_parts[1])
                        cip_value = split(cip_str, " ", limit: 2)
                        .unifi_client_ip = to_string(cip_value[0])
                      }
                    } else if contains(extension, "UNIFIclientIP=") {
                      cip_parts = split(extension, "UNIFIclientIP=", limit: 2)
                      if length(cip_parts) > 1 {
                        cip_str = to_string(cip_parts[1])
                        cip_value = split(cip_str, " ", limit: 2)
                        .unifi_client_ip = to_string(cip_value[0])
                      }
                    }

                    if contains(extension, "UNIFIclientMac=") {
                      mac_parts = split(extension, "UNIFIclientMac=", limit: 2)
                      if length(mac_parts) > 1 {
                        mac_str = to_string(mac_parts[1])
                        mac_value = split(mac_str, " ", limit: 2)
                        .unifi_client_mac = to_string(mac_value[0])
                      }
                    }

                    # Device fields
                    if contains(extension, "UNIFIdeviceName=") {
                      dname_parts = split(extension, "UNIFIdeviceName=", limit: 2)
                      if length(dname_parts) > 1 {
                        dname_str = to_string(dname_parts[1])
                        dname_value = split(dname_str, " ", limit: 2)
                        .unifi_device_name = to_string(dname_value[0])
                      }
                    }

                    # WiFi fields
                    if contains(extension, "UNIFIwifiName=") {
                      wifi_parts = split(extension, "UNIFIwifiName=", limit: 2)
                      if length(wifi_parts) > 1 {
                        wifi_str = to_string(wifi_parts[1])
                        wifi_value = split(wifi_str, " ", limit: 2)
                        .unifi_wifi_name = to_string(wifi_value[0])
                      }
                    }
                  }

                  # Set event type based on device_event_class_id
                  device_id = .device_event_class_id
                  .event_type = if device_id == "544" {
                    "admin_access"
                  } else if device_id == "401" {
                    "wifi_disconnect"
                  } else if device_id == "400" {
                    "wifi_connect"
                  } else if device_id == "system" {
                    "system_event"
                  } else if device_id == "admins" {
                    "admin_login"
                  } else {
                    "unifi_event"
                  }

                  # Clean up the original message field
                  del(.message)
                } else {
                  .event_type = "cef_parse_failed"
                  .parse_error = "Not enough CEF fields"
                }
              }
            }

            # Add metadata
            .source_type = "unifi"
            .processed_at = now()
      sinks:
        console_debug:
          type: console
          inputs: ["parse_unifi_cef"]
          encoding:
            codec: json
        to_loki:
          type: loki
          inputs: ["parse_unifi_cef"]
          endpoint: "http://loki-gateway.observability.svc.cluster.local:80"
          encoding:
            codec: json
          labels:
            source: "unifi"
            device: "{{`{{ unifi_host }}`}}"
            job: "syslog"
            event_type: "{{`{{ event_type }}`}}"
            category: "{{`{{ unifi_category }}`}}"
            subcategory: "{{`{{ unifi_subcategory }}`}}"
            severity: "{{`{{ severity }}`}}"
          out_of_order_action: "accept"
